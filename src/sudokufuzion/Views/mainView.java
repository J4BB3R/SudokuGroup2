/**
 * 
 *   //-- Create by J4BB3R<johanmaurel@gmail.com> --//
 *
 *   [Initial Date] : 08/12/2016
 *   [Last Date] : 11/12/2016
 *   [Description] :
 *      This class is the game view;
 *   [Increments] :
 *      - 09/12/2016 [v0.1] : Creation of the views;
 *      - 11/12/2016 [v0.2] : Adding KeyListener for the GridControler
 * 
 **/

package sudokufuzion.Views;
import sudokufuzion.Views.Components.GridMainPanel;
import sudokufuzion.Views.Components.GridCase;
import java.awt.Point;
import java.util.Observable;
import java.util.Observer;
import sudokufuzion.Controler.GridControler;
import sudokufuzion.Controler.GridEvents.Case;
import sudokufuzion.Controler.GridEvents.ChangeValueEvent;
import sudokufuzion.Controler.GridEvents.ErrorEvent;
import sudokufuzion.Controler.GridEvents.MoveFocusEvent;

public class mainView extends javax.swing.JFrame implements Observer{

    // Panel Configuration
    private final static int LOCATION_X = 57, LOCATION_Y = 57;
    
    // Moving Focus Configuration
    private final static int GRID_SIZE = 9;
    private final static int SUB_GRID_SIZE = 3;
    public final static int UP = 0, DOWN = 2, LEFT = -1, RIGHT = 1, ERROR = -2;
    
    //====================//
    // Instance Attribute //
    //====================//
    
    private GridControler gc;
    private final GridCase grid[][] = new GridCase[GRID_SIZE][GRID_SIZE];
    private final Point focusedCase = new Point(0,0);
    private Point errorCase;
    
    public mainView() {}
    
    public mainView(GridControler gc) {
        
        this.gc = gc;
        
        /////////////////////////////////
        //--Instanciation of the Grid--//
        /////////////////////////////////
        
        int X, Y, x, y, valTabY, valTabX;
        for(int i=0; i < GRID_SIZE; i++){
            
            GridMainPanel buff = new GridMainPanel();
            X = LOCATION_X + buff.getWidth()*(i%SUB_GRID_SIZE); // Calculate position of the containerGrid
            Y = LOCATION_Y + buff.getHeight()*(i/SUB_GRID_SIZE); // Calculate position of the containerGrid
            buff.setLocation(X,Y);
            GridCase c = new GridCase();
            
            for (int z=0; z < GRID_SIZE; z++) {
                
                valTabY = z/SUB_GRID_SIZE + SUB_GRID_SIZE*(i/SUB_GRID_SIZE); // Calculate the index value into the tab
                valTabX = z%SUB_GRID_SIZE + SUB_GRID_SIZE*(i%SUB_GRID_SIZE); // Calculate the index value into the tab
                
                GridCase caseBuff = new GridCase();
                caseBuff.setName("case["+valTabY+"]["+valTabX+"]");
                
                x = X + caseBuff.getWidth()*(z%SUB_GRID_SIZE) + GridMainPanel.BORDER_SIZE; // Calculate position compare to the parentGrid relative position 
                y = Y + caseBuff.getHeight()*(z/SUB_GRID_SIZE) + GridMainPanel.BORDER_SIZE; // Calculate position compare to the parentGrid relative position 
                
                caseBuff.setLocation(x,y); // Setting location
                
                this.add(caseBuff);
                
                grid[valTabY][valTabX] = caseBuff; // Component is save into the matrix;
            }
            
            this.add(buff);
        }
      
        focusedCase.setLocation(0,0);
        gc.setFocusedCase(focusedCase);
        grid[focusedCase.y][focusedCase.x].setState(GridCase.FOCUS);
        
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("SUDOKU FUZION");
        setMinimumSize(new java.awt.Dimension(400, 400));
        setSize(new java.awt.Dimension(400, 400));
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        panel.setBackground(new java.awt.Color(40, 40, 40));

        javax.swing.GroupLayout panelLayout = new javax.swing.GroupLayout(panel);
        panel.setLayout(panelLayout);
        panelLayout.setHorizontalGroup(
            panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        panelLayout.setVerticalGroup(
            panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        gc.addToTasksQueue(evt); // Push KeyEvent into the controler
    }//GEN-LAST:event_formKeyPressed

    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(mainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(mainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(mainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(mainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new mainView().setVisible(true);
        });
    }
    
    public void moveFocus(int Move) {
        try {
            GridCase gc;
            switch (Move) {
                case UP :
                    gc = grid[focusedCase.y][focusedCase.x];
                    gc.setState(gc.getPreviousState());
                    if(focusedCase.y == 0) focusedCase.y = GRID_SIZE - 1;
                    else focusedCase.y--;
                    grid[focusedCase.y][focusedCase.x].setState(GridCase.FOCUS);
                break;
                case DOWN :
                    gc = grid[focusedCase.y][focusedCase.x];
                    gc.setState(gc.getPreviousState());
                    if(focusedCase.y == GRID_SIZE - 1) focusedCase.y = 0;
                    else focusedCase.y++;
                    grid[focusedCase.y][focusedCase.x].setState(GridCase.FOCUS);
                break;
                case LEFT :
                    gc = grid[focusedCase.y][focusedCase.x];
                    gc.setState(gc.getPreviousState());
                    if(focusedCase.x == 0) focusedCase.x = GRID_SIZE - 1;
                    else focusedCase.x--;
                    grid[focusedCase.y][focusedCase.x].setState(GridCase.FOCUS);
                break;
                case RIGHT :
                    gc = grid[focusedCase.y][focusedCase.x];
                    gc.setState(gc.getPreviousState());
                    if(focusedCase.x == GRID_SIZE - 1) focusedCase.x = 0;
                    else focusedCase.x++;
                    grid[focusedCase.y][focusedCase.x].setState(GridCase.FOCUS);
                break;
                default :
                    throw(new Exception(new Throwable("[mainView] MovingFocus Error unknow command.")));
            } this.gc.setFocusedCase(focusedCase);
        } catch(Exception e) {
            e.printStackTrace();
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel panel;
    // End of variables declaration//GEN-END:variables

    @Override
    public void update(Observable o, Object o1) {
        
        if ( o1 instanceof MoveFocusEvent ) moveFocus(((MoveFocusEvent) o1).getMove());
        else if ( o1 instanceof ChangeValueEvent) setValueIntoCase((ChangeValueEvent) o1);
        else if ( o1 instanceof ErrorEvent) setErrorIntoCase((ErrorEvent) o1);
        
    }

    private void setValueIntoCase(ChangeValueEvent evt) {
        GridCase g;
        for (Case c: evt) {
            if (c.value != 0) {
                if (c.getInitial()) {
                    g = grid[c.y][c.x];
                    g.setText(String.valueOf(c.value));
                    g.setForeground(GridCase.NON_MODIFABLE_COLOR);
                } else {
                    if (errorCase != null) this.unsetErrorIntoCase();
                    grid[c.y][c.x].setText(String.valueOf(c.value));
                }
            }
        }
    }
    
    public void setErrorIntoCase(ErrorEvent ev) {
        
        this.unsetErrorIntoCase();
        
        Point initialCase = ev.getInitialCase();
        errorCase = initialCase;
        GridCase gcn = grid[errorCase.y][errorCase.x];
        gcn.setErrorEvent(ev);
        gcn.setColorErrorInitialCase();
        
        ev.stream().forEach((pt) -> {
            grid[pt.y][pt.x].setState(GridCase.ERROR);
        });
        
    }
    
    public void unsetErrorIntoCase() {
        if (errorCase != null) {
            
            GridCase gco = grid[errorCase.y][errorCase.x];
            gco.unsetColorErrorInitialCase();
            gco.setPreviousText();
            GridCase buff;
            
            for (Point pt : gco.getErrorEvent()) {
                buff = grid[pt.y][pt.x];
                buff.setState(buff.getPreviousState());
            } 
            
            gco.setErrorEvent(null);
            
            errorCase = null;
            
        }        
    }
    
}
