/**
 * 
 *   //-- Create by J4BB3R<johanmaurel@gmail.com> --//
 *
 *   [Initial Date] : 08/12/2016
 *   [Last Date] : 12/12/2016
 *   [Description] :
 *      This class is the game view;
 *   [Increments] :
 *      - 09/12/2016 [v0.1] : Creation of the views;
 *      - 11/12/2016 [v0.2] : Adding KeyListener for the GridControler
 *      - 12/12/2016 [v0.3] : Modify to handle basic comportement
 * 
 **/

package sudokufuzion.Views;
import sudokufuzion.Views.Components.GridMainPanel;
import sudokufuzion.Views.Components.GridCase;
import java.awt.Point;
import java.util.Observable;
import java.util.Observer;
import javax.swing.JOptionPane;
import sudokufuzion.Controler.GridControler;
import sudokufuzion.Controler.GridEvents.Case;
import sudokufuzion.Controler.GridEvents.ChangeValueEvent;
import sudokufuzion.Controler.GridEvents.ErrorEvent;
import sudokufuzion.Controler.GridEvents.MoveFocusEvent;

public class mainView extends javax.swing.JFrame implements Observer { // THe Class 

    // Panel Configuration
    private final static int LOCATION_X = 57, LOCATION_Y = 57; // 0,0 Of the grid 
    
    // Moving Focus Configuration
    private final static int GRID_SIZE = 9; // Grid Size in case unit
    private final static int SUB_GRID_SIZE = 3; // Sub Grid Size in case unit
    public final static int UP = 0, DOWN = 2, LEFT = -1, RIGHT = 1, ERROR = -2; // All move, usable from the outside, by GridControler in fact
    
    //====================//
    // Instance Attribute //
    //====================//
    
    private GridControler gc; 
    private final GridCase grid[][] = new GridCase[GRID_SIZE][GRID_SIZE];
    private final Point focusedCase = new Point(0,0); 
    private Point errorCase;
    
    public mainView() {}
    
    public mainView(GridControler gc) {
        
        this.gc = gc;
        
        /////////////////////////////////
        //--Instanciation of the Grid--//
        /////////////////////////////////
        
        int X, Y, x, y, valTabY, valTabX;
        for(int i=0; i < GRID_SIZE; i++){
            
            GridMainPanel buff = new GridMainPanel();
            X = LOCATION_X + buff.getWidth()*(i%SUB_GRID_SIZE); // Calculate position of the containerGrid
            Y = LOCATION_Y + buff.getHeight()*(i/SUB_GRID_SIZE); // Calculate position of the containerGrid
            buff.setLocation(X,Y);
            GridCase c = new GridCase();
            
            for (int z=0; z < GRID_SIZE; z++) {
                
                valTabY = z/SUB_GRID_SIZE + SUB_GRID_SIZE*(i/SUB_GRID_SIZE); // Calculate the index value into the tab
                valTabX = z%SUB_GRID_SIZE + SUB_GRID_SIZE*(i%SUB_GRID_SIZE); // Calculate the index value into the tab
                
                GridCase caseBuff = new GridCase();
                caseBuff.setName("case["+valTabY+"]["+valTabX+"]");
                
                x = X + caseBuff.getWidth()*(z%SUB_GRID_SIZE) + GridMainPanel.BORDER_SIZE; // Calculate position compare to the parentGrid relative position 
                y = Y + caseBuff.getHeight()*(z/SUB_GRID_SIZE) + GridMainPanel.BORDER_SIZE; // Calculate position compare to the parentGrid relative position 
                
                caseBuff.setLocation(x,y); // Setting location
                
                this.add(caseBuff); // Copy Component to Context
                
                grid[valTabY][valTabX] = caseBuff; // Component is save into the matrix;
            }
            
            this.add(buff); // Copy Component to Context
        }
      
        focusedCase.setLocation(0,0); // Set initial Location 
        gc.setFocusedCase(focusedCase); // Give Ref@ to GridControler
        grid[focusedCase.y][focusedCase.x].setState(GridCase.FOCUS); // Set Focus into the initial Location GridCase
        
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("SUDOKU FUZION");
        setMinimumSize(new java.awt.Dimension(400, 400));
        setSize(new java.awt.Dimension(400, 400));
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        panel.setBackground(new java.awt.Color(40, 40, 40));

        javax.swing.GroupLayout panelLayout = new javax.swing.GroupLayout(panel);
        panel.setLayout(panelLayout);
        panelLayout.setHorizontalGroup(
            panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        panelLayout.setVerticalGroup(
            panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        gc.addToTasksQueue(evt); // Push KeyEvent into the Grid Controler
    }//GEN-LAST:event_formKeyPressed

    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(mainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(mainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(mainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(mainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new mainView().setVisible(true);
        });
    }
    
    public void moveFocus(int Move) {
        try {
            GridCase gc;
            switch (Move) {
                case UP : // Change value according to UP y-- and x
                    setPreviousState();
                    if(focusedCase.y == 0) focusedCase.y = GRID_SIZE - 1; // Infinite Loop in Grid bottom to top
                    else focusedCase.y--;
                    grid[focusedCase.y][focusedCase.x].setState(GridCase.FOCUS);
                break;
                case DOWN : // Change value according to UP y++ and x
                    setPreviousState();
                    if(focusedCase.y == GRID_SIZE - 1) focusedCase.y = 0; // Infinite Loop in Grid top to bottom
                    else focusedCase.y++;
                    grid[focusedCase.y][focusedCase.x].setState(GridCase.FOCUS);
                break;
                case LEFT : // Change value according to UP y and x--
                    setPreviousState();
                    if(focusedCase.x == 0) focusedCase.x = GRID_SIZE - 1; // Infinite Loop in Grid left to right
                    else focusedCase.x--;
                    grid[focusedCase.y][focusedCase.x].setState(GridCase.FOCUS);
                break;
                case RIGHT : // Change value according to UP y and x++
                    setPreviousState();
                    if(focusedCase.x == GRID_SIZE - 1) focusedCase.x = 0; // Infinite Loop in Grid right to left
                    else focusedCase.x++;
                    grid[focusedCase.y][focusedCase.x].setState(GridCase.FOCUS);
                break;
                default :
                    throw(new Exception(new Throwable("[mainView] MovingFocus Error unknow command.")));
                    
            } // *
            
        } catch(Exception e) {
            e.printStackTrace();
        }
    }
    
    private void setPreviousState() { // Set previous State into a GridCase
        GridCase gc = grid[focusedCase.y][focusedCase.x];
        gc.setState(gc.getPreviousState());
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel panel;
    // End of variables declaration//GEN-END:variables

    @Override
    public void update(Observable o, Object o1) { // Observer update method, it's running when GridControler have notify view
        
        if ( o1 instanceof MoveFocusEvent ) moveFocus(((MoveFocusEvent) o1).getMove()); // Handle Event Move
        else if ( o1 instanceof ChangeValueEvent) setValueIntoCase((ChangeValueEvent) o1); // Handle Event Value Change
        else if ( o1 instanceof ErrorEvent) setErrorIntoCase((ErrorEvent) o1); // Handle Event Error appears
        else modalFinalPopUp(((GridControler) o).getCountTry()); // o1 = null for the Sudoku Finish
        
    }

    private void setValueIntoCase(ChangeValueEvent evt) {
        GridCase g;
        for (Case c: evt) { // For Each Element to Change
            if (c.value != 0) {
                if (c.getInitial()) { // Set Initial Case as Initialisation of the GridControler
                    g = grid[c.y][c.x];
                    g.setText(String.valueOf(c.value));
                    g.setForeground(GridCase.NON_MODIFABLE_COLOR);
                } else { // Set Normal Value Case
                    if (errorCase != null ) this.unsetErrorIntoCase(); // unset previous displayed Error
                    grid[c.y][c.x].setText(String.valueOf(c.value));
                }
            } else { // Set blank value when press on Suppr = 0
                if (errorCase != null ) this.unsetErrorIntoCase(); // unset previous displayed Error
                grid[c.y][c.x].setText(""); // Blank Value
            }
        }
    }
    
    public void setErrorIntoCase(ErrorEvent ev) {
        
        this.unsetErrorIntoCase(); // unset previous displayed Error
        
        Point initialCase = ev.getInitialCase();                // Set Error into the Case who generate the error
        errorCase = initialCase;                                //
        GridCase gcn = grid[errorCase.y][errorCase.x];          //
        gcn.setErrorEvent(ev);                                  //
        gcn.setColorErrorInitialCase();                         //
        
        ev.stream().forEach((pt) -> {
            grid[pt.y][pt.x].setState(GridCase.ERROR);          // Set Error into the satellites 
        });
        
    }
    
    public void unsetErrorIntoCase() {
        if (errorCase != null) {    // If previous exist 
            
            GridCase gco = grid[errorCase.y][errorCase.x];      // Unset Error into the Case who generate the error
            gco.unsetColorErrorInitialCase();                   //
            gco.setPreviousText();                              //
            GridCase buff;                                      //
            
            for (Point pt : gco.getErrorEvent()) {
                buff = grid[pt.y][pt.x];                       // Unset Error into the satellites
                
                if (buff.getState() != GridCase.FOCUS) buff.setState(buff.getPreviousState());
                else buff.setPreviousState(GridCase.BASE);     /* Special Comportement Needed : Error Focused have to stay 
                                                    in Focus and set previous as Base when you delete value inside it */
                
            } 
            
            gco.setErrorEvent(null); // Destroy ErrorEvent
            
            errorCase = null; // No Error Remaining
            
        }        
    }
    
    private void modalFinalPopUp(int count) { // Modal Pop Up, Player Win !!!
        Object[] opt = { "Oui", "Non" };
        int ret = JOptionPane.showOptionDialog(this, "Tu as reussis en "+count+" Coups \nTu veux refaire une partie ..? ", "BRAVO Tu as Gagné !!!",
                JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, opt, opt[1]); // Config pop UP with count
        if (ret == 0) gc.reloadNewGrid(); // reload a New Grid
        else System.exit(0); // Qwick and Dirty ;)
    }
    
}
